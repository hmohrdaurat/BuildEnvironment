diff --git a/scripts/setup-helper-functions.sh b/scripts/setup-helper-functions.sh
index 078454f8c..cd150cdb3 100755
--- a/scripts/setup-helper-functions.sh
+++ b/scripts/setup-helper-functions.sh
@@ -269,6 +269,8 @@ function cmake_install {
     -GNinja \
     -DCMAKE_POLICY_VERSION_MINIMUM=3.5 \
     -DCMAKE_POSITION_INDEPENDENT_CODE=ON \
+    -DCMAKE_CXX_COMPILER=clang++ \
+    -DCMAKE_C_COMPILER=clang \
     "${INSTALL_PREFIX+-DCMAKE_PREFIX_PATH=}${INSTALL_PREFIX-}" \
     "${INSTALL_PREFIX+-DCMAKE_INSTALL_PREFIX=}${INSTALL_PREFIX-}" \
     -DCMAKE_CXX_FLAGS="$COMPILER_FLAGS" \
diff --git a/scripts/setup-ubuntu.sh b/scripts/setup-ubuntu.sh
index ead291910..cb36e7edf 100755
--- a/scripts/setup-ubuntu.sh
+++ b/scripts/setup-ubuntu.sh
@@ -224,7 +224,7 @@ function install_adapters {
 }
 
 function install_faiss_deps {
-  sudo apt-get install -y libopenblas-dev libomp-dev
+  sudo apt-get install -y libopenblas-dev libomp-15-dev
 }
 
 function install_velox_deps {
diff --git a/velox/exec/HashBuild.cpp b/velox/exec/HashBuild.cpp
index 4e44d6f71..41d7e1a97 100644
--- a/velox/exec/HashBuild.cpp
+++ b/velox/exec/HashBuild.cpp
@@ -144,7 +144,8 @@ void HashBuild::setupTable() {
         operatorCtx_->driverCtx()
             ->queryConfig()
             .minTableRowsForParallelJoinBuild(),
-        pool());
+        pool(),
+        operatorCtx_->driverCtx()->queryConfig().hashAdaptivityEnabled());
   } else {
     // (Left) semi and anti join with no extra filter only needs to know whether
     // there is a match. Hence, no need to store entries with duplicate keys.
@@ -164,7 +165,8 @@ void HashBuild::setupTable() {
           operatorCtx_->driverCtx()
               ->queryConfig()
               .minTableRowsForParallelJoinBuild(),
-          pool());
+          pool(),
+          operatorCtx_->driverCtx()->queryConfig().hashAdaptivityEnabled());
     } else {
       // Ignore null keys
       table_ = HashTable<true>::createForJoin(
@@ -175,7 +177,8 @@ void HashBuild::setupTable() {
           operatorCtx_->driverCtx()
               ->queryConfig()
               .minTableRowsForParallelJoinBuild(),
-          pool());
+          pool(),
+          operatorCtx_->driverCtx()->queryConfig().hashAdaptivityEnabled());
     }
   }
   analyzeKeys_ = table_->hashMode() != BaseHashTable::HashMode::kHash;
diff --git a/velox/exec/HashProbe.cpp b/velox/exec/HashProbe.cpp
index 7bbfe4765..2239f02db 100644
--- a/velox/exec/HashProbe.cpp
+++ b/velox/exec/HashProbe.cpp
@@ -27,12 +27,6 @@ using facebook::velox::common::testutil::TestValue;
 
 namespace facebook::velox::exec {
 
-namespace {
-
-// Batch size used when iterating the row container.
-constexpr int kBatchSize = 1024;
-} // namespace
-
 // static
 RowTypePtr HashProbe::makeTableType(
     const RowType* type,
@@ -1254,10 +1248,10 @@ void HashProbe::prepareFilterRowsForNullAwareJoin(
     RowVectorPtr& filterInput,
     vector_size_t numRows,
     bool filterPropagateNulls) {
-  VELOX_CHECK_LE(numRows, kBatchSize);
+  VELOX_CHECK_LE(numRows, outputBatchSize_);
   if (filterTableInput_ == nullptr) {
     filterTableInput_ =
-        BaseVector::create<RowVector>(filterInputType_, kBatchSize, pool());
+        BaseVector::create<RowVector>(filterInputType_, outputBatchSize_, pool());
   }
 
   if (filterPropagateNulls) {
@@ -1338,8 +1332,8 @@ void HashProbe::applyFilterOnTableRowsForNullAwareJoin(
     return;
   }
   VELOX_CHECK(table_->rows(), "Should not move rows in hash joins");
-  char* data[kBatchSize];
-  while (auto numRows = iterator(data, kBatchSize)) {
+  char** data = new char*[outputBatchSize_];
+  while (auto numRows = iterator(data, outputBatchSize_)) {
     filterTableInput_->resize(numRows);
     filterTableInputRows_.resizeFill(numRows, true);
     for (auto& projection : filterTableProjections_) {
@@ -1382,6 +1376,7 @@ void HashProbe::applyFilterOnTableRowsForNullAwareJoin(
       }
     });
   }
+  delete[] data;
 }
 
 SelectivityVector HashProbe::evalFilterForNullAwareJoin(
diff --git a/velox/exec/HashTable.cpp b/velox/exec/HashTable.cpp
index 4c4a8c463..fea614421 100644
--- a/velox/exec/HashTable.cpp
+++ b/velox/exec/HashTable.cpp
@@ -52,18 +52,25 @@ HashTable<ignoreNullKeys>::HashTable(
     bool isJoinBuild,
     bool hasProbedFlag,
     uint32_t minTableSizeForParallelJoinBuild,
-    memory::MemoryPool* pool)
+    memory::MemoryPool* pool, bool hashAdaptivityEnabled)
     : BaseHashTable(std::move(hashers)),
       pool_(pool),
       minTableSizeForParallelJoinBuild_(minTableSizeForParallelJoinBuild),
       isJoinBuild_(isJoinBuild),
       buildPartitionBounds_(raw_vector<PartitionBoundIndexType>(pool)) {
   std::vector<TypePtr> keys;
-  for (auto& hasher : hashers_) {
-    keys.push_back(hasher->type());
-    if (!VectorHasher::typeKindSupportsValueIds(hasher->typeKind())) {
-      hashMode_ = HashMode::kHash;
+  if (hashAdaptivityEnabled) {
+    for (auto& hasher : hashers_) {
+      keys.push_back(hasher->type());
+      if (!VectorHasher::typeKindSupportsValueIds(hasher->typeKind())) {
+        hashMode_ = HashMode::kHash;
+      }
     }
+  else {
+    for (auto& hasher : hashers_) {
+      keys.push_back(hasher->type());
+    }
+    hashMode_ = HashMode::kHash;
   }
 
   rows_ = std::make_unique<RowContainer>(
diff --git a/velox/exec/HashTable.h b/velox/exec/HashTable.h
index c19d74727..2079068ee 100644
--- a/velox/exec/HashTable.h
+++ b/velox/exec/HashTable.h
@@ -485,7 +485,8 @@ class HashTable : public BaseHashTable {
       bool isJoinBuild,
       bool hasProbedFlag,
       uint32_t minTableSizeForParallelJoinBuild,
-      memory::MemoryPool* pool);
+      memory::MemoryPool* pool,
+      bool hashAdaptivityEnabled = true);
 
   ~HashTable() override = default;
 
@@ -510,7 +511,8 @@ class HashTable : public BaseHashTable {
       bool allowDuplicates,
       bool hasProbedFlag,
       uint32_t minTableSizeForParallelJoinBuild,
-      memory::MemoryPool* pool) {
+      memory::MemoryPool* pool,
+      bool hashAdaptivityEnabled = true) {
     return std::make_unique<HashTable>(
         std::move(hashers),
         std::vector<Accumulator>{},
@@ -519,7 +521,8 @@ class HashTable : public BaseHashTable {
         true, // isJoinBuild
         hasProbedFlag,
         minTableSizeForParallelJoinBuild,
-        pool);
+        pool,
+        hashAdaptivityEnabled);
   }
 
   void groupProbe(HashLookup& lookup, int8_t spillInputStartPartitionBit)
diff --git a/velox/exec/Task.h b/velox/exec/Task.h
index 4768ef2f0..ea1d1bf4f 100644
--- a/velox/exec/Task.h
+++ b/velox/exec/Task.h
@@ -780,6 +780,10 @@ class Task : public std::enable_shared_from_this<Task> {
   /// Returns true if all the splits have finished.
   bool testingAllSplitsFinished();
 
+  auto const& childPools() const {
+    return childPools_;
+  }
+
  private:
   // Hook of system-wide running task list.
   struct TaskListEntry {
diff --git a/velox/functions/prestosql/Arithmetic.h b/velox/functions/prestosql/Arithmetic.h
index 836e073be..2980d162e 100644
--- a/velox/functions/prestosql/Arithmetic.h
+++ b/velox/functions/prestosql/Arithmetic.h
@@ -124,6 +124,17 @@ struct IntervalMultiplyFunction {
   }
 };
 
+template <typename T>
+struct MixedMultiplyFunction {
+  FOLLY_ALWAYS_INLINE void call(double& result, double a, int64_t b) {
+    result = multiply(a, b);
+  }
+
+  FOLLY_ALWAYS_INLINE void call(double& result, int64_t a, double b) {
+    result = multiply(a, b);
+  }
+};
+
 template <typename T>
 struct DivideFunction {
   template <typename TInput>
@@ -182,6 +193,33 @@ struct IntervalDivideFunction {
   }
 };
 
+template <typename T>
+struct MixedDivideFunction {
+  FOLLY_ALWAYS_INLINE void
+  call(double& result, const double& a, const int64_t& b)
+// depend on compiler have correct behaviour for divide by zero
+#if defined(__has_feature)
+#if __has_feature(__address_sanitizer__)
+      __attribute__((__no_sanitize__("float-divide-by-zero")))
+#endif
+#endif
+  {
+    result = a / b;
+  }
+
+  FOLLY_ALWAYS_INLINE void
+  call(double& result, const int64_t& a, const double& b)
+// depend on compiler have correct behaviour for divide by zero
+#if defined(__has_feature)
+#if __has_feature(__address_sanitizer__)
+      __attribute__((__no_sanitize__("float-divide-by-zero")))
+#endif
+#endif
+  {
+    result = a / b;
+  }
+};
+
 template <typename T>
 struct ModulusFunction {
   template <typename TInput>
diff --git a/velox/functions/prestosql/ArithmeticImpl.h b/velox/functions/prestosql/ArithmeticImpl.h
index a7b85dd78..46f4afcd2 100644
--- a/velox/functions/prestosql/ArithmeticImpl.h
+++ b/velox/functions/prestosql/ArithmeticImpl.h
@@ -126,6 +126,17 @@ T multiply(const T a, const T b)
   return a * b;
 }
 
+template <typename T, typename U>
+T multiply(const T a, const U b)
+#if defined(__has_feature)
+#if __has_feature(__address_sanitizer__)
+    __attribute__((__no_sanitize__("signed-integer-overflow")))
+#endif
+#endif
+{
+  return a * b;
+}
+
 // This is used by Velox for floating points divide.
 template <typename T>
 T divide(const T& a, const T& b)
@@ -139,6 +150,18 @@ T divide(const T& a, const T& b)
   return result;
 }
 
+template <typename T, typename U>
+T divide(const T& a, const U& b)
+#if defined(__has_feature)
+#if __has_feature(__address_sanitizer__)
+    __attribute__((__no_sanitize__("float-divide-by-zero")))
+#endif
+#endif
+{
+  T result = a / b;
+  return result;
+}
+
 // This is used by Velox for floating points modulus.
 template <typename T>
 T modulus(const T a, const T b) {
diff --git a/velox/functions/prestosql/registration/MathematicalOperatorsRegistration.cpp b/velox/functions/prestosql/registration/MathematicalOperatorsRegistration.cpp
index bab24264a..9229d8f0d 100644
--- a/velox/functions/prestosql/registration/MathematicalOperatorsRegistration.cpp
+++ b/velox/functions/prestosql/registration/MathematicalOperatorsRegistration.cpp
@@ -79,6 +79,10 @@ void registerMathOperators(const std::string& prefix = "") {
       IntervalYearMonth,
       double,
       IntervalYearMonth>({prefix + "multiply"});
+  registerFunction<MixedMultiplyFunction, double, double, int64_t>(
+      {prefix + "multiply"});
+  registerFunction<MixedMultiplyFunction, double, int64_t, double>(
+      {prefix + "multiply"});
   registerBinaryFloatingPoint<DivideFunction>({prefix + "divide"});
   registerFunction<
       IntervalDivideFunction,
@@ -90,6 +94,10 @@ void registerMathOperators(const std::string& prefix = "") {
       IntervalYearMonth,
       IntervalYearMonth,
       double>({prefix + "divide"});
+  registerFunction<MixedDivideFunction, double, double, int64_t>(
+      {prefix + "divide"});
+  registerFunction<MixedDivideFunction, double, int64_t, double>(
+      {prefix + "divide"});
   registerBinaryFloatingPoint<ModulusFunction>({prefix + "mod"});
 }
 
